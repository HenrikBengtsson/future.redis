% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/redis.R
\name{redis}
\alias{redis}
\title{Redis-based futures}
\usage{
redis(
  expr,
  envir = parent.frame(),
  substitute = TRUE,
  globals = TRUE,
  queue = "RJOBS",
  config = redis_config(),
  output_queue = NA,
  max_retries = 3,
  ...
)
}
\arguments{
\item{expr}{An \R \link[base]{expression}.}

\item{envir}{The \link{environment} from where global objects should be
identified.}

\item{substitute}{If TRUE, argument \code{expr} is
\code{\link[base]{substitute}()}:ed, otherwise not.}

\item{globals}{(optional) a logical, a character vector, a named list, or
a [globals::Globals] object.  If `TRUE`, globals are identified by code
inspection based on `expr` and `tweak` searching from environment
`envir`.  If `FALSE`, no globals are used.  If a character vector, then
globals are identified by lookup based their names `globals` searching
from environment `envir`.  If a named list or a Globals object, the
globals are used as is.}

\item{queue}{Redis key name of the task queue (Redis list).}

\item{config}{Redis config.}

\item{output_queue}{(optional) Redis key name of the work output queue
(note: reserved for future use).}

\item{max_retries}{Maximum number of times the future can be re-submitted
to the task queue in the event of failure.}

\item{...}{Additional named elements of the future.}
}
\value{
An object of class [RedisFuture].
}
\description{
Use the Redis key/value database to define partially fault-tolerant,
asynchronous task queues for elastic distributed computing.
}
\examples{
if (redux::redis_available()) {
## The example assumes that a Redis server is running on the local host
## and standard port.

# Register the redis plan on a specified task queue:
plan(redis, queue = "R jobs")

# Start some local R worker processes:
startLocalWorkers(n=2, queue="R jobs", linger=1)

# Alternatively, use the following to run the workers quietly without
# showing messages as they run:
# startLocalWorkers(n=2, queue="R jobs", linger=1, log="/dev/null")

# A function that returns a future, note that N uses lexical scoping...
f <- \() future({4 * sum((runif(N) ^ 2 + runif(N) ^ 2) < 1) / N}, seed = TRUE)

# Run a simple sampling approximation of pi in parallel using  M * N points:
N <- 1e6  # samples per worker
M <- 10   # iterations
Reduce(sum, Map(value, replicate(M, f()))) / M

# Clean up
removeQ("R jobs")
}
}
\seealso{
\code{\link{redis_config}}, \code{\link{worker}}, \code{\link{removeQ}}
}
